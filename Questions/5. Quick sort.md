### 5. Quick sort

Quick sort is probably one of the most used sorting algorithms. The reason for this is that it is fairly easy to implement and fairly fast in most applications. It is in-place which means that differently from the merge sort it does only use a small auxiliary array so it does not consume the same amount of memory as with the merge sort. In the merge sort you have to copy the whole array which means that you will need double the memory capacity in order to sort the array. It sorts in average in N log N but in worst case if the data is already sorted it will do it in N^2. In order to ensure good performance we need to make sure that the data is not sorted, so implementing a shuffle method is a good idea.

The problem with a array of sorted items is that it will find a partitioning element after which it will search that all left elements should be lower and right elements should be higher, then swap lo and hi if this is not the case and finally swap the partition element with the j index. So if the partitioning element only finds elements greater than itself it will run through the whole list and establish that there is no one lower, then continue to the next element and do so again which then leads to N^2 time. In average when using shuffle it will be around ~1.39N lg N compares and exchanges will be around ~1/2N lg N. So it is fairly fast any average cases.